"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const querystring_1 = __importDefault(require("querystring"));
const url_1 = __importDefault(require("url"));
const axios_error_1 = __importDefault(require("axios-error"));
const form_data_1 = __importDefault(require("form-data"));
const append_query_1 = __importDefault(require("append-query"));
const axios_1 = __importDefault(require("axios"));
const get_1 = __importDefault(require("lodash/get"));
const ts_invariant_1 = __importDefault(require("ts-invariant"));
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
const omit_1 = __importDefault(require("lodash/omit"));
const warning_1 = __importDefault(require("warning"));
const messaging_api_common_1 = require("messaging-api-common");
const Messenger_1 = __importDefault(require("./Messenger"));
function extractVersion(version) {
    if (version.startsWith('v')) {
        return version.slice(1);
    }
    return version;
}
function handleError(err) {
    if (err.response && err.response.data) {
        const error = get_1.default(err, 'response.data.error');
        if (error) {
            const msg = `Messenger API - ${error.code} ${error.type} ${error.message}`;
            throw new axios_error_1.default(msg, err);
        }
    }
    throw new axios_error_1.default(err.message, err);
}
class MessengerClient {
    constructor(config) {
        ts_invariant_1.default(typeof config !== 'string', `MessengerClient: do not allow constructing client with ${config} string. Use object instead.`);
        this.accessToken = config.accessToken;
        ts_invariant_1.default(!config.version || typeof config.version === 'string', 'Type of `version` must be string.');
        this.appId = config.appId;
        this.appSecret = config.appSecret;
        this.version = extractVersion(config.version || '6.0');
        this.onRequest = config.onRequest;
        const { origin } = config;
        let skipAppSecretProof;
        if (typeof config.skipAppSecretProof === 'boolean') {
            skipAppSecretProof = config.skipAppSecretProof;
        }
        else {
            skipAppSecretProof = this.appSecret == null;
        }
        this.axios = axios_1.default.create({
            baseURL: `${origin || 'https://graph.facebook.com'}/v${this.version}/`,
            headers: { 'Content-Type': 'application/json' },
            transformRequest: [
                // axios use any as type of the data in AxiosTransformer
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (data) => data && isPlainObject_1.default(data) ? messaging_api_common_1.snakecaseKeysDeep(data) : data,
                ...axios_1.default.defaults.transformRequest,
            ],
            // `transformResponse` allows changes to the response data to be made before
            // it is passed to then/catch
            transformResponse: [
                ...axios_1.default.defaults.transformResponse,
                // axios use any as type of the data in AxiosTransformer
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (data) => data && isPlainObject_1.default(data) ? messaging_api_common_1.camelcaseKeysDeep(data) : data,
            ],
        });
        this.axios.interceptors.request.use(messaging_api_common_1.createRequestInterceptor({ onRequest: this.onRequest }));
        // add appsecret_proof to request
        if (!skipAppSecretProof) {
            ts_invariant_1.default(this.appSecret, 'Must provide appSecret when skipAppSecretProof is false');
            const appSecret = this.appSecret;
            this.axios.interceptors.request.use((requestConfig) => {
                const isBatch = requestConfig.url === '/' && Array.isArray(requestConfig.data.batch);
                if (isBatch) {
                    // eslint-disable-next-line no-param-reassign
                    requestConfig.data.batch = requestConfig.data.batch.map((item) => {
                        const urlParts = url_1.default.parse(item.relativeUrl, true);
                        let accessToken = get_1.default(urlParts, 'query.access_token');
                        if (!accessToken && item.body) {
                            const entries = decodeURIComponent(item.body)
                                .split('&')
                                .map((pair) => pair.split('='));
                            const accessTokenEntry = entries.find(([key]) => key === 'access_token');
                            if (accessTokenEntry) {
                                accessToken = accessTokenEntry[1];
                            }
                        }
                        if (accessToken) {
                            const appSecretProof = crypto_1.default
                                .createHmac('sha256', appSecret)
                                .update(accessToken, 'utf8')
                                .digest('hex');
                            return Object.assign(Object.assign({}, item), { relativeUrl: append_query_1.default(item.relativeUrl, {
                                    appsecret_proof: appSecretProof,
                                }) });
                        }
                        return item;
                    });
                }
                const urlParts = url_1.default.parse(requestConfig.url || '', true);
                const accessToken = get_1.default(urlParts, 'query.access_token', this.accessToken);
                const appSecretProof = crypto_1.default
                    .createHmac('sha256', appSecret)
                    .update(accessToken, 'utf8')
                    .digest('hex');
                // eslint-disable-next-line no-param-reassign
                requestConfig.url = append_query_1.default(requestConfig.url || '', {
                    appsecret_proof: appSecretProof,
                });
                return requestConfig;
            });
        }
    }
    /**
     * @deprecated Use `new MessengerClient(...)` instead.
     */
    static connect(config) {
        warning_1.default(false, '`MessengerClient.connect(...)` is deprecated. Use `new MessengerClient(...)` instead.');
        return new MessengerClient(config);
    }
    /**
     * Get Page Info
     *
     * https://developers.facebook.com/docs/graph-api/reference/page/
     * id, name
     */
    getPageInfo({ fields, accessToken: customAccessToken, } = {}) {
        return this.axios
            .get('/me', {
            params: {
                access_token: customAccessToken || this.accessToken,
                fields: fields ? fields.join(',') : undefined,
            },
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Debug Token
     *
     * https://developers.facebook.com/docs/facebook-login/access-tokens/debugging-and-error-handling
     */
    debugToken({ accessToken: customAccessToken, } = {}) {
        ts_invariant_1.default(this.appId, 'App ID is required to debug token');
        ts_invariant_1.default(this.appSecret, 'App Secret is required to debug token');
        const accessToken = `${this.appId}|${this.appSecret}`;
        return this.axios
            .get(`/debug_token`, {
            params: {
                input_token: customAccessToken || this.accessToken,
                access_token: accessToken,
            },
        })
            .then((res) => res.data.data, handleError);
    }
    /**
     * Create Subscription
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
    createSubscription({ object = 'page', callbackUrl, fields = [
        'messages',
        'messaging_postbacks',
        'messaging_optins',
        'messaging_referrals',
        'messaging_handovers',
        'messaging_policy_enforcement',
    ], includeValues, verifyToken, accessToken: appAccessToken, }) {
        const { appId } = this;
        ts_invariant_1.default(appId, 'App ID is required to create subscription');
        ts_invariant_1.default(this.appSecret || appAccessToken, 'App Secret or App Token is required to create subscription');
        const accessToken = appAccessToken || `${appId}|${this.appSecret}`;
        return this.axios
            .post(`/${appId}/subscriptions?access_token=${accessToken}`, {
            object,
            callbackUrl,
            fields: fields.join(','),
            includeValues,
            verifyToken,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Get Subscriptions
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
    getSubscriptions({ accessToken: appAccessToken, } = {}) {
        const { appId } = this;
        ts_invariant_1.default(appId, 'App ID is required to get subscriptions');
        ts_invariant_1.default(this.appSecret || appAccessToken, 'App Secret or App Token is required to get subscriptions');
        const accessToken = appAccessToken || `${appId}|${this.appSecret}`;
        return this.axios
            .get(`/${appId}/subscriptions?access_token=${accessToken}`)
            .then((res) => res.data.data, handleError);
    }
    /**
     * Extract page subscription from subscriptions
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
    getPageSubscription({ accessToken: appAccessToken, } = {}) {
        const { appId } = this;
        ts_invariant_1.default(appId, 'App ID is required to get subscription');
        ts_invariant_1.default(this.appSecret || appAccessToken, 'App Secret or App Token is required to get subscription');
        const accessToken = appAccessToken || `${appId}|${this.appSecret}`;
        return this.getSubscriptions({
            accessToken,
        }).then((subscriptions) => subscriptions.filter((subscription) => subscription.object === 'page')[0] || null);
    }
    /**
     *  Messaging Feature Review API
     *
     *  https://developers.facebook.com/docs/messenger-platform/reference/messaging-feature-review-api
     */
    getMessagingFeatureReview({ accessToken: customAccessToken, } = {}) {
        return this.axios
            .get(`/me/messaging_feature_review?access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data, handleError);
    }
    /**
     * Get User Profile
     *
     * https://www.quora.com/How-connect-Facebook-user-id-to-sender-id-in-the-Facebook-messenger-platform
     * first_name, last_name, profile_pic, locale, timezone, gender
     */
    getUserProfile(userId, { fields = ['id', 'name', 'first_name', 'last_name', 'profile_pic'], accessToken: customAccessToken, } = {}) {
        return this.axios
            .get(`/${userId}?fields=${fields.join(',')}&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Messenger Profile
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api
     */
    getMessengerProfile(fields, { accessToken: customAccessToken } = {}) {
        return this.axios
            .get(`/me/messenger_profile?fields=${fields.join(',')}&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data, handleError);
    }
    setMessengerProfile(profile, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/messenger_profile?access_token=${customAccessToken || this.accessToken}`, profile)
            .then((res) => res.data, handleError);
    }
    deleteMessengerProfile(fields, { accessToken: customAccessToken } = {}) {
        return this.axios
            .delete(`/me/messenger_profile?access_token=${customAccessToken || this.accessToken}`, {
            data: {
                fields,
            },
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Get Started Button
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/get-started-button
     */
    getGetStarted(options = {}) {
        return this.getMessengerProfile(['get_started'], options).then((res) => res[0]
            ? res[0].getStarted
            : null);
    }
    setGetStarted(payload, options = {}) {
        return this.setMessengerProfile({
            getStarted: {
                payload,
            },
        }, options);
    }
    deleteGetStarted(options = {}) {
        return this.deleteMessengerProfile(['get_started'], options);
    }
    /**
     * Persistent Menu
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/persistent-menu
     */
    getPersistentMenu(options = {}) {
        return this.getMessengerProfile(['persistent_menu'], options).then((res) => res[0] ? res[0].persistentMenu : null);
    }
    setPersistentMenu(menuItems, _a = {}) {
        var { composerInputDisabled = false } = _a, options = __rest(_a, ["composerInputDisabled"]);
        // locale is in type PersistentMenuItem
        if (menuItems.some((item) => 'locale' in item && item.locale === 'default')) {
            return this.setMessengerProfile({
                persistentMenu: menuItems,
            }, options);
        }
        // menuItems is in type MenuItem[]
        return this.setMessengerProfile({
            persistentMenu: [
                {
                    locale: 'default',
                    composerInputDisabled,
                    callToActions: menuItems,
                },
            ],
        }, options);
    }
    deletePersistentMenu(options = {}) {
        return this.deleteMessengerProfile(['persistent_menu'], options);
    }
    /**
     * User Level Persistent Menu
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/persistent-menu#user_level_menu
     */
    getUserPersistentMenu(userId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .get(`/me/custom_user_settings?psid=${userId}&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data[0]
            ? res.data.data[0].userLevelPersistentMenu
            : null, handleError);
    }
    setUserPersistentMenu(userId, menuItems, { composerInputDisabled = false, accessToken: customAccessToken, } = {}) {
        // locale is in type PersistentMenuItem
        if (menuItems.some((item) => 'locale' in item && item.locale === 'default')) {
            return this.axios
                .post(`/me/custom_user_settings?access_token=${customAccessToken || this.accessToken}`, {
                psid: userId,
                persistentMenu: menuItems,
            })
                .then((res) => res.data, handleError);
        }
        // menuItems is in type MenuItem[]
        return this.axios
            .post(`/me/custom_user_settings?access_token=${customAccessToken || this.accessToken}`, {
            psid: userId,
            persistentMenu: [
                {
                    locale: 'default',
                    composerInputDisabled,
                    callToActions: menuItems,
                },
            ],
        })
            .then((res) => res.data, handleError);
    }
    deleteUserPersistentMenu(userId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .delete(`/me/custom_user_settings?psid=${userId}&params=[%22persistent_menu%22]&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Greeting Text
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/greeting
     */
    getGreeting(options = {}) {
        return this.getMessengerProfile(['greeting'], options).then((res) => res[0] ? res[0].greeting : null);
    }
    setGreeting(greeting, options = {}) {
        if (typeof greeting === 'string') {
            return this.setMessengerProfile({
                greeting: [
                    {
                        locale: 'default',
                        text: greeting,
                    },
                ],
            }, options);
        }
        return this.setMessengerProfile({
            greeting,
        }, options);
    }
    deleteGreeting(options = {}) {
        return this.deleteMessengerProfile(['greeting'], options);
    }
    /**
     * Ice Breakers
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/ice-breakers
     */
    getIceBreakers(options = {}) {
        return this.getMessengerProfile(['ice_breakers'], options).then((res) => res[0] ? res[0].iceBreakers : null);
    }
    setIceBreakers(iceBreakers, options = {}) {
        return this.setMessengerProfile({
            iceBreakers,
        }, options);
    }
    deleteIceBreakers(options = {}) {
        return this.deleteMessengerProfile(['ice_breakers'], options);
    }
    /**
     * Whitelisted Domains
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/domain-whitelisting
     */
    getWhitelistedDomains(options = {}) {
        return this.getMessengerProfile(['whitelisted_domains'], options).then((res) => (res[0] ? res[0].whitelistedDomains : null));
    }
    setWhitelistedDomains(whitelistedDomains, options = {}) {
        return this.setMessengerProfile({
            whitelistedDomains,
        }, options);
    }
    deleteWhitelistedDomains(options = {}) {
        return this.deleteMessengerProfile(['whitelisted_domains'], options);
    }
    /**
     * Account Linking URL
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/account-linking-url
     */
    getAccountLinkingURL(options = {}) {
        return this.getMessengerProfile(['account_linking_url'], options).then((res) => (res[0] ? res[0] : null));
    }
    setAccountLinkingURL(accountLinkingUrl, options = {}) {
        return this.setMessengerProfile({
            accountLinkingUrl,
        }, options);
    }
    deleteAccountLinkingURL(options = {}) {
        return this.deleteMessengerProfile(['account_linking_url'], options);
    }
    /**
     * Chat Extension Home URL
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/home-url
     */
    getHomeURL(options = {}) {
        return this.getMessengerProfile(['home_url'], options).then((res) => res[0]
            ? res[0]
            : null);
    }
    setHomeURL(homeUrl, { webviewHeightRatio = 'tall', webviewShareButton, inTest, }, options = {}) {
        return this.setMessengerProfile({
            homeUrl: {
                url: homeUrl,
                webviewHeightRatio,
                inTest,
                webviewShareButton,
            },
        }, options);
    }
    deleteHomeURL(options = {}) {
        return this.deleteMessengerProfile(['home_url'], options);
    }
    /**
     * Message tags
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags
     */
    getMessageTags({ accessToken: customAccessToken, } = {}) {
        return this.axios
            .get(`/page_message_tags?access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data, handleError);
    }
    /**
     * Send API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/send-api
     */
    sendRawBody(body) {
        const { accessToken: customAccessToken } = body;
        return this.axios
            .post(`/me/messages?access_token=${customAccessToken || this.accessToken}`, body)
            .then((res) => res.data, handleError);
    }
    sendMessage(psidOrRecipient, message, options = {}) {
        const recipient = typeof psidOrRecipient === 'string'
            ? {
                id: psidOrRecipient,
            }
            : psidOrRecipient;
        let messagingType = 'UPDATE';
        if (options.messagingType) {
            messagingType = options.messagingType;
        }
        else if (options.tag) {
            messagingType = 'MESSAGE_TAG';
        }
        return this.sendRawBody(Object.assign({ messagingType,
            recipient, message: Messenger_1.default.createMessage(message, options) }, omit_1.default(options, 'quickReplies')));
    }
    sendMessageFormData(psidOrRecipient, formdata, options = {}) {
        const recipient = typeof psidOrRecipient === 'string'
            ? {
                id: psidOrRecipient,
            }
            : psidOrRecipient;
        let messagingType = 'UPDATE';
        if (options.messagingType) {
            messagingType = options.messagingType;
        }
        else if (options.tag) {
            messagingType = 'MESSAGE_TAG';
        }
        formdata.append('messaging_type', messagingType);
        formdata.append('recipient', JSON.stringify(messaging_api_common_1.snakecaseKeysDeep(recipient)));
        return this.axios
            .post(`/me/messages?access_token=${options.accessToken || this.accessToken}`, formdata, {
            headers: formdata.getHeaders(),
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Content Types
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages#content_types
     */
    sendAttachment(psidOrRecipient, attachment, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createAttachment(attachment, options), options);
    }
    sendText(psidOrRecipient, text, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createText(text, options), options);
    }
    sendAudio(psidOrRecipient, audio, options) {
        if (Buffer.isBuffer(audio) || audio instanceof fs_1.default.ReadStream) {
            const message = Messenger_1.default.createAudioFormData(audio, options);
            return this.sendMessageFormData(psidOrRecipient, message, options);
        }
        const message = Messenger_1.default.createAudio(audio, options);
        return this.sendMessage(psidOrRecipient, message, options);
    }
    sendImage(psidOrRecipient, image, options) {
        if (Buffer.isBuffer(image) || image instanceof fs_1.default.ReadStream) {
            const message = Messenger_1.default.createImageFormData(image, options);
            return this.sendMessageFormData(psidOrRecipient, message, options);
        }
        const message = Messenger_1.default.createImage(image, options);
        return this.sendMessage(psidOrRecipient, message, options);
    }
    sendVideo(psidOrRecipient, video, options) {
        if (Buffer.isBuffer(video) || video instanceof fs_1.default.ReadStream) {
            const message = Messenger_1.default.createVideoFormData(video, options);
            return this.sendMessageFormData(psidOrRecipient, message, options);
        }
        const message = Messenger_1.default.createVideo(video, options);
        return this.sendMessage(psidOrRecipient, message, options);
    }
    sendFile(psidOrRecipient, file, options) {
        if (Buffer.isBuffer(file) || file instanceof fs_1.default.ReadStream) {
            const message = Messenger_1.default.createFileFormData(file, options);
            return this.sendMessageFormData(psidOrRecipient, message, options);
        }
        const message = Messenger_1.default.createFile(file, options);
        return this.sendMessage(psidOrRecipient, message, options);
    }
    /**
     * Message Templates
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/templates
     */
    sendTemplate(psidOrRecipient, payload, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createTemplate(payload, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/button
    sendButtonTemplate(psidOrRecipient, text, buttons, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createButtonTemplate(text, buttons, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/generic
    sendGenericTemplate(psidOrRecipient, elements, options = {}) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createGenericTemplate(elements, options), omit_1.default(options, ['imageAspectRatio']));
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/receipt
    sendReceiptTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createReceiptTemplate(attrs, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/media
    sendMediaTemplate(psidOrRecipient, elements, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createMediaTemplate(elements, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#boarding_pass
    sendAirlineBoardingPassTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createAirlineBoardingPassTemplate(attrs, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#check_in
    sendAirlineCheckinTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createAirlineCheckinTemplate(attrs, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#itinerary
    sendAirlineItineraryTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createAirlineItineraryTemplate(attrs, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#update
    sendAirlineUpdateTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createAirlineUpdateTemplate(attrs, options), options);
    }
    // https://developers.facebook.com/docs/messenger-platform/send-messages/one-time-notification/#one-time-notif
    sendOneTimeNotifReqTemplate(psidOrRecipient, attrs, options) {
        return this.sendMessage(psidOrRecipient, Messenger_1.default.createOneTimeNotifReqTemplate(attrs, options), options);
    }
    /**
     * Typing
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/sender-actions
     */
    sendSenderAction(psidOrRecipient, senderAction, { accessToken: customAccessToken } = {}) {
        const recipient = typeof psidOrRecipient === 'string'
            ? {
                id: psidOrRecipient,
            }
            : psidOrRecipient;
        return this.sendRawBody({
            recipient,
            senderAction,
            accessToken: customAccessToken,
        });
    }
    markSeen(psidOrRecipient, options = {}) {
        return this.sendSenderAction(psidOrRecipient, 'mark_seen', options);
    }
    typingOn(psidOrRecipient, options = {}) {
        return this.sendSenderAction(psidOrRecipient, 'typing_on', options);
    }
    typingOff(psidOrRecipient, options = {}) {
        return this.sendSenderAction(psidOrRecipient, 'typing_off', options);
    }
    /**
     * Send Batch Request
     *
     * https://developers.facebook.com/docs/graph-api/making-multiple-requests
     */
    sendBatch(batch, { includeHeaders = true, accessToken: customAccessToken, } = {}) {
        ts_invariant_1.default(batch.length <= 50, 'limit the number of requests which can be in a batch to 50');
        const responseAccessPaths = batch.map((item) => item.responseAccessPath);
        const bodyEncodedbatch = batch
            .map((item) => omit_1.default(item, 'responseAccessPath'))
            .map((item) => {
            if (item.body) {
                const body = messaging_api_common_1.snakecaseKeysDeep(item.body);
                return Object.assign(Object.assign({}, item), { body: Object.keys(body)
                        .map((key) => {
                        const val = body[key];
                        return `${encodeURIComponent(key)}=${encodeURIComponent(typeof val === 'object' ? JSON.stringify(val) : val)}`;
                    })
                        .join('&') });
            }
            return item;
        });
        return this.axios
            .post('/', {
            accessToken: customAccessToken || this.accessToken,
            includeHeaders,
            batch: bodyEncodedbatch,
        })
            .then((res) => res.data.map((item, index) => {
            const responseAccessPath = responseAccessPaths[index];
            const datum = messaging_api_common_1.camelcaseKeysDeep(item);
            if (datum.body) {
                const parsedBody = messaging_api_common_1.camelcaseKeysDeep(JSON.parse(datum.body));
                return Object.assign(Object.assign({}, datum), { body: responseAccessPath
                        ? get_1.default(parsedBody, responseAccessPath)
                        : parsedBody });
            }
            return datum;
        }), handleError);
    }
    /**
     * Label API
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts
     */
    /**
     * Create Label
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#create_label
     */
    createLabel(name, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/custom_labels?access_token=${customAccessToken || this.accessToken}`, {
            name,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Associating a Label to a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#associate_label
     */
    associateLabel(userId, labelId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/${labelId}/label?access_token=${customAccessToken || this.accessToken}`, {
            user: userId,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Removing a Label From a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#remove_label
     */
    dissociateLabel(userId, labelId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .delete(`/${labelId}/label?access_token=${customAccessToken || this.accessToken}`, {
            data: { user: userId },
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Retrieving Labels Associated with a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#retrieving_labels_by_psid
     */
    getAssociatedLabels(userId, options = {}) {
        const fields = options.fields ? options.fields.join(',') : 'name';
        return this.axios
            .get(`/${userId}/custom_labels?fields=${fields}&access_token=${options.accessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Retrieving Label Details
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#get_label_details
     */
    getLabelDetails(labelId, options = {}) {
        const fields = options.fields ? options.fields.join(',') : 'name';
        return this.axios
            .get(`/${labelId}?fields=${fields}&access_token=${options.accessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Retrieving a List of All Labels
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#get_all_labels
     */
    getLabelList(options = {}) {
        const fields = options.fields ? options.fields.join(',') : 'name';
        return this.axios
            .get(`/me/custom_labels?fields=${fields}&access_token=${options.accessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Deleting a Label
     *
     * https://developers.facebook.com/docs/messenger-platform/identity/custom-labels#delete_label
     */
    deleteLabel(labelId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .delete(`/${labelId}?access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Upload API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/attachment-upload-api
     */
    // FIXME: [type] return type
    uploadAttachment(type, attachment, options = {}) {
        const args = [];
        const isReusable = options.isReusable || false;
        if (typeof attachment === 'string') {
            args.push({
                message: {
                    attachment: {
                        type,
                        payload: {
                            url: attachment,
                            isReusable,
                        },
                    },
                },
            });
        }
        else {
            const form = new form_data_1.default();
            form.append('message', JSON.stringify({
                attachment: {
                    type,
                    payload: {
                        is_reusable: isReusable,
                    },
                },
            }));
            form.append('filedata', attachment, omit_1.default(options, ['is_reusable']));
            args.push(form, {
                headers: form.getHeaders(),
                maxContentLength: Infinity,
            });
        }
        return this.axios
            .post(`/me/message_attachments?access_token=${options.accessToken || this.accessToken}`, ...args)
            .then((res) => res.data, handleError);
    }
    // FIXME: use TypeScript overloading
    uploadAudio(attachment, options) {
        return this.uploadAttachment('audio', attachment, options);
    }
    // FIXME: use TypeScript overloading
    uploadImage(attachment, options) {
        return this.uploadAttachment('image', attachment, options);
    }
    // FIXME: use TypeScript overloading
    uploadVideo(attachment, options) {
        return this.uploadAttachment('video', attachment, options);
    }
    // FIXME: use TypeScript overloading
    uploadFile(attachment, options) {
        return this.uploadAttachment('file', attachment, options);
    }
    /**
     * Handover Protocol API
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol
     */
    /**
     * Pass Thread Control
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/pass-thread-control
     */
    passThreadControl(recipientId, targetAppId, metadata, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/pass_thread_control?access_token=${customAccessToken || this.accessToken}`, {
            recipient: { id: recipientId },
            targetAppId,
            metadata,
        })
            .then((res) => res.data, handleError);
    }
    passThreadControlToPageInbox(recipientId, metadata, options = {}) {
        return this.passThreadControl(recipientId, 263902037430900, metadata, options);
    }
    /**
     * Take Thread Control
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/take-thread-control
     */
    takeThreadControl(recipientId, metadata, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/take_thread_control?access_token=${customAccessToken || this.accessToken}`, {
            recipient: { id: recipientId },
            metadata,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Request Thread Control
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol/request-thread-control/
     */
    requestThreadControl(recipientId, metadata, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/request_thread_control?access_token=${customAccessToken || this.accessToken}`, {
            recipient: { id: recipientId },
            metadata,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * Secondary Receivers List
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/secondary-receivers
     */
    getSecondaryReceivers({ accessToken: customAccessToken, } = {}) {
        return this.axios
            .get(`/me/secondary_receivers?fields=id,name&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data, handleError);
    }
    /**
     * Getting the Thread Owner
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol/get-thread-owner
     */
    getThreadOwner(recipientId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .get(`/me/thread_owner?recipient=${recipientId}&access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data.data[0].threadOwner, handleError);
    }
    /**
     * Page Messaging Insights API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messaging-insights-api
     */
    getInsights(metrics, options = {}) {
        return this.axios
            .get(`/me/insights/?${querystring_1.default.stringify(Object.assign({ metric: metrics.join(','), access_token: options.accessToken || this.accessToken }, options))}`)
            .then((res) => res.data.data, handleError);
    }
    getBlockedConversations(options) {
        return this.getInsights(['page_messages_blocked_conversations_unique'], options).then((result) => result[0]);
    }
    getReportedConversations(options) {
        return this.getInsights(['page_messages_reported_conversations_unique'], options).then((result) => result[0]);
    }
    // https://developers.facebook.com/docs/messenger-platform/reference/messaging-insights-api?locale=en_US#metrics
    // This metrics replaces the page_messages_open_conversations_unique metric, which was deprecated on May 11, 2018.
    getTotalMessagingConnections(options) {
        return this.getInsights(['page_messages_total_messaging_connections'], options).then((result) => result[0]);
    }
    getNewConversations(options) {
        return this.getInsights(['page_messages_new_conversations_unique'], options).then((result) => result[0]);
    }
    /**
     * Built-in NLP API
     *
     * https://developers.facebook.com/docs/messenger-platform/built-in-nlp
     */
    // FIXME: [type] return type
    setNLPConfigs(config = {}, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/nlp_configs?${querystring_1.default.stringify(messaging_api_common_1.snakecaseKeysDeep(config))}`, {
            accessToken: customAccessToken || this.accessToken,
        })
            .then((res) => res.data, handleError);
    }
    // FIXME: [type] return type
    enableNLP(options = {}) {
        return this.setNLPConfigs({ nlpEnabled: true }, options);
    }
    // FIXME: [type] return type
    disableNLP(options = {}) {
        return this.setNLPConfigs({ nlpEnabled: false }, options);
    }
    /**
     * Logging Custom Events
     *
     * https://developers.facebook.com/docs/app-events/bots-for-messenger#logging-custom-events
     */
    // FIXME: [type] return type
    logCustomEvents({ appId, pageId, pageScopedUserId, events, }) {
        return this.axios
            .post(`/${appId}/activities`, {
            event: 'CUSTOM_APP_EVENTS',
            customEvents: JSON.stringify(events),
            advertiserTrackingEnabled: 0,
            applicationTrackingEnabled: 0,
            extinfo: JSON.stringify(['mb1']),
            pageId,
            pageScopedUserId,
        })
            .then((res) => res.data, handleError);
    }
    /**
     * https://developers.facebook.com/docs/messenger-platform/identity/id-matching#examples
     */
    // FIXME: [type] return type
    getUserField({ field, userId, appSecret, app, page, accessToken: customAccessToken, }) {
        const accessToken = customAccessToken || this.accessToken;
        // $appsecret_proof= hash_hmac('sha256', $access_token, $app_secret);
        const appsecretProof = crypto_1.default
            .createHmac('sha256', appSecret)
            .update(accessToken)
            .digest('hex');
        const appQueryString = app ? `&app=${app}` : '';
        const pageQueryString = page ? `&page=${page}` : '';
        return this.axios
            .get(`/${userId}/${field}?access_token=${accessToken}&appsecret_proof=${appsecretProof}${appQueryString}${pageQueryString}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Given a user ID for a bot in Messenger, retrieve the IDs for apps owned by the same business
     */
    // FIXME: [type] return type
    getIdsForApps({ userId, appSecret, app, page, accessToken, }) {
        return this.getUserField({
            field: 'ids_for_apps',
            userId,
            appSecret,
            app,
            page,
            accessToken,
        });
    }
    /**
     * Given a user ID for a Page (associated with a bot), retrieve the IDs for other Pages owned by the same business
     */
    // FIXME: [type] return type
    getIdsForPages({ userId, appSecret, app, page, accessToken, }) {
        return this.getUserField({
            field: 'ids_for_pages',
            userId,
            appSecret,
            app,
            page,
            accessToken,
        });
    }
    /**
     * Personas API
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas
     */
    /**
     * Creating a Persona
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#create
     */
    createPersona(persona, { accessToken: customAccessToken } = {}) {
        return this.axios
            .post(`/me/personas?access_token=${customAccessToken || this.accessToken}`, persona)
            .then((res) => res.data, handleError);
    }
    /**
     * Retrieving a Persona
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#get
     */
    getPersona(personaId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .get(`/${personaId}?access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
    /**
     * Retrieving All Available Personas
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#retrieve_all
     */
    getPersonas(cursor, { accessToken: customAccessToken } = {}) {
        return this.axios
            .get(`/me/personas?access_token=${customAccessToken || this.accessToken}${cursor ? `&after=${cursor}` : ''}`)
            .then((res) => res.data, handleError);
    }
    getAllPersonas({ accessToken: customAccessToken, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let allPersonas = [];
            let cursor;
            do {
                const { data, paging, } = yield this.getPersonas(cursor, {
                    accessToken: customAccessToken,
                });
                allPersonas = allPersonas.concat(data);
                cursor = paging ? paging.cursors.after : null;
            } while (cursor);
            return allPersonas;
        });
    }
    /**
     * Deleting a Persona
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#remove
     */
    deletePersona(personaId, { accessToken: customAccessToken } = {}) {
        return this.axios
            .delete(`/${personaId}?access_token=${customAccessToken || this.accessToken}`)
            .then((res) => res.data, handleError);
    }
}
exports.default = MessengerClient;
//# sourceMappingURL=MessengerClient.js.map