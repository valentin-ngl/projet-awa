"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const isAfter_1 = __importDefault(require("date-fns/isAfter"));
const isValid_1 = __importDefault(require("date-fns/isValid"));
const warning_1 = __importDefault(require("warning"));
const messaging_api_messenger_1 = require("messaging-api-messenger");
const FacebookBaseConnector_1 = __importDefault(require("./FacebookBaseConnector"));
const MessengerContext_1 = __importDefault(require("./MessengerContext"));
const MessengerEvent_1 = __importDefault(require("./MessengerEvent"));
class MessengerConnector extends FacebookBaseConnector_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { ClientClass: messaging_api_messenger_1.MessengerClient }));
        this._mapPageToAccessToken = null;
        const { mapPageToAccessToken, skipLegacyProfile } = options;
        this._mapPageToAccessToken = mapPageToAccessToken || null;
        this._skipLegacyProfile =
            typeof skipLegacyProfile === 'boolean' ? skipLegacyProfile : true;
    }
    _getRawEventsFromRequest(body) {
        if ('entry' in body) {
            return body.entry
                .map((entry) => {
                if ('messaging' in entry) {
                    return entry.messaging[0];
                }
                if ('standby' in entry) {
                    return entry.standby[0];
                }
                return null;
            })
                .filter((event) => event != null);
        }
        return [body];
    }
    _getPageIdFromRawEvent(rawEvent) {
        if ('message' in rawEvent && rawEvent.message.isEcho && rawEvent.sender) {
            return rawEvent.sender.id;
        }
        if (rawEvent.recipient) {
            return rawEvent.recipient.id;
        }
        return null;
    }
    _isStandby(body) {
        if (!('entry' in body))
            return false;
        const entry = body.entry[0];
        return 'standby' in entry;
    }
    _profilePicExpired(user) {
        try {
            const ext = new url_1.URL(user.profilePic).searchParams.get('ext');
            if (!ext)
                return true;
            const timestamp = +ext * 1000;
            const expireTime = new Date(timestamp);
            return !(isValid_1.default(expireTime) && isAfter_1.default(expireTime, new Date()));
        }
        catch (e) {
            return true;
        }
    }
    get platform() {
        return 'messenger';
    }
    getUniqueSessionKey(bodyOrEvent) {
        const rawEvent = bodyOrEvent instanceof MessengerEvent_1.default
            ? bodyOrEvent.rawEvent
            : this._getRawEventsFromRequest(bodyOrEvent)[0];
        if (rawEvent &&
            'message' in rawEvent &&
            rawEvent.message.isEcho &&
            rawEvent.recipient) {
            return rawEvent.recipient.id;
        }
        if (rawEvent && 'sender' in rawEvent) {
            return rawEvent.sender.id;
        }
        return null;
    }
    updateSession(session, bodyOrEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!session.user || this._profilePicExpired(session.user)) {
                const senderId = this.getUniqueSessionKey(bodyOrEvent);
                const rawEvent = bodyOrEvent instanceof MessengerEvent_1.default
                    ? bodyOrEvent.rawEvent
                    : this._getRawEventsFromRequest(bodyOrEvent)[0];
                const pageId = this._getPageIdFromRawEvent(rawEvent);
                let customAccessToken;
                if (!pageId) {
                    warning_1.default(false, 'Could not find pageId from request body.');
                }
                else {
                    session.page = {
                        id: pageId,
                        _updatedAt: new Date().toISOString(),
                    };
                    if (this._mapPageToAccessToken != null) {
                        const mapPageToAccessToken = this._mapPageToAccessToken;
                        customAccessToken = yield mapPageToAccessToken(pageId);
                    }
                }
                if (this._skipLegacyProfile) {
                    session.user = {
                        _updatedAt: new Date().toISOString(),
                        id: senderId,
                    };
                }
                else {
                    let user = {};
                    try {
                        user = yield this._client.getUserProfile(senderId, {
                            accessToken: customAccessToken,
                        });
                    }
                    catch (err) {
                        warning_1.default(false, 'getUserProfile() failed, `session.user` will only have `id`');
                        console.error(err);
                    }
                    session.user = Object.assign(Object.assign({ _updatedAt: new Date().toISOString() }, user), { id: senderId });
                }
            }
            Object.freeze(session.user);
            Object.defineProperty(session, 'user', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: session.user,
            });
            Object.freeze(session.page);
            Object.defineProperty(session, 'page', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: session.page,
            });
        });
    }
    mapRequestToEvents(body) {
        const rawEvents = this._getRawEventsFromRequest(body);
        const isStandby = this._isStandby(body);
        return rawEvents.map((rawEvent) => new MessengerEvent_1.default(rawEvent, {
            isStandby,
            pageId: this._getPageIdFromRawEvent(rawEvent),
        }));
    }
    createContext(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let customAccessToken;
            if (this._mapPageToAccessToken) {
                const { rawEvent } = params.event;
                let pageId = null;
                if ('message' in rawEvent && rawEvent.message.isEcho && rawEvent.sender) {
                    pageId = rawEvent.sender.id;
                }
                else if (rawEvent.recipient) {
                    pageId = rawEvent.recipient.id;
                }
                if (!pageId) {
                    warning_1.default(false, 'Could not find pageId from request body.');
                }
                else {
                    customAccessToken = yield this._mapPageToAccessToken(pageId);
                }
            }
            return new MessengerContext_1.default(Object.assign(Object.assign({}, params), { client: this._client, customAccessToken, batchQueue: this._batchQueue, appId: this._appId }));
        });
    }
}
exports.default = MessengerConnector;
//# sourceMappingURL=MessengerConnector.js.map